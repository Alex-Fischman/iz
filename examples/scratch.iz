fib := n -> if (n == 0) 1 else fib@(n-1) + n

# Data : Const@Int -> Type
Int : Type = Data@8

Bool := Data@1
true  : Bool = 1
false : Bool = 0
# if   : Bool     -> a -> Option@a
# else : Option@a -> a -> a
or  := a -> b -> if a true else b
and := a -> b -> if a b    else false

# Struct : [Type] -> Type
Token := Struct@[String Int Int]
str : Token -> _ = access@0
col : Token -> _ = access@1
row : Token -> _ = access@2

# Enum : [Type] -> Type
AST := Enum@[
	Token
	List := Struct@[Token [AST] Token]
	Call := Struct@[AST AST]
]

# fmt : Const@String -> f where (f : _ -> f or f : String)
toString : Token -> String = fmt@"{}@{}:{}"@token.str@token.row@token.col

tokenize := s -> {
	is_bracket := a -> "(){}[]".chars.any@(b -> a == b)
	char_type := c -> ((c.is_alphabetic || c.is_numeric || c == '') as Int << 0) + 
		((c.is_whitespace) as Int << 1) + 
		((c.is_bracket) as Int << 2)

	row := 1
	col := 1
	tokens := []
	in_comment := false
	in_string := false

	tokens.push@["{" 0 0]
	s.chars.map@(c -> {
		if in_comment {
			if c == '\n' {
				in_comment = false
			}
		}
		else if c == "#" in_comment = true
		else if in_string {
			tokens.last.unwrap.str.push@c
			if c == "\"" in_string = false
		}
		else if c == "\"" {
			in_string = true
			tokens.push@[c.to_string row col]
		}
		else if tokens.empty || c.is_bracket || c.char_type != tokens.last.unwrap.char_type
			tokens.push@[c.to_string row col]
		else tokens.last.unwrap.str.push@c

		if c == "\n" {
			row += 1
			col = 1
		}
		else col += 1
	})
	tokens.push@["}" 0 0]

	tokens.filter@(t -> !t.string.chars.next.unwrap.is_whitespace)
}
