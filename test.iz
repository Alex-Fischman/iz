#match ( ) group
#match { } block
#match [ ] list

#affix =  assign 2 1 0 l
#affix :  type   2 1 0 l
#affix := define 2 1 0 l
#affix -> func   2 1 1 r

#affix | or  2 1 2 l
#affix & and 2 1 2 l
#affix ^ xor 2 1 2 l
#affix ! not 1 0 3 l

#affix == eq  2 1 4 l
#affix != neq 2 1 4 l
#affix <  lt  2 1 4 l
#affix >  gt  2 1 4 l
#affix <= lte 2 1 4 l
#affix >= gte 2 1 4 l

#affix + add 2 1 5 l
#affix - sub 2 1 5 l
#affix * mul 2 1 6 l
#affix / div 2 1 6 l
#affix % mod 2 1 6 l
#affix ** pow 2 1 7 l

#affix . dot  2 1 8 l
#affix $ call 2 1 9 l

Distance := Float
Vector := (Distance Distance Distance)

1st = (x _ _) -> x
2nd = (_ y _) -> y
3rd = (_ _ z) -> z
len = (x y z) -> sqrt$(x^2 + y^2 + z^2)
add = ((a b c) (x y z)) -> (a+x b+y c+z)
sub = ((a b c) (x y z)) -> (a-x b-y c-z)
max = vs -> (vs.map$1st.max vs.map$2nd.max vs.map$3rd.max)
min = vs -> (vs.map$1st.min vs.map$2nd.min vs.map$3rd.min)
iter = (x y z) -> [x y z]

SDF := Vector -> Distance

sphere : SDF = v -> len$v - 1

translate : Vector -> SDF -> SDF
translate = t      -> sdf -> v -> sdf$(v - t)
translate : Distance -> SDF -> SDF
scale     = s        -> sdf -> v -> sdf$(v / s) * s

union : (SDF SDF) -> SDF
union = (a   b  ) -> v -> min$[a$v b$v]
intersection : (SDF SDF) -> SDF
intersection = (a   b  ) -> v -> max$[a$v b$v]
difference : (SDF SDF) -> SDF
difference = (a   b  ) -> v -> max$[a$v 0-b$v]
